#+title: Dsa

* Arrays
** Static Arrays
- Storing and accessing sequential data
- temp storage of objects
- used by IO routines as buffers
- lookup tables and inverse lookup tables
- can be used to return multiple values from a function
- used in dynamic programming to cache answers to subproblems
*** Complexity
- Access: O(1)
- Search: O(n)
** Dynamic Arrays
- can grow and shrink in size
*** Complexity
- Access: O(1)
- Search: O(n)
- Insertion: O(n)
- Appending: O(1)
- Deletion: O(n)
*** Creating Dynamic Arrays
- Using Static arrays:
  * Create static array with init size
  * Add elements to underlying array keeping number of elements tracked
  * If adding element will overflow, create another array of 2x(size) and copy contents of first arr into second

#+BEGIN_SRC cpp

@SuppressWarnings("unchecked")
public class Array<T> implements Iterable<T> {
    T[] arr;
    int len = 0;
    int capacity = 0;

public:
    Array() { this(16); }
    Array(int capacity) {
        if (capacity < 0) throw new IllegalArgumentException("Illegal Capacity: " + capacity);
        this.capacity = capacity;
    }
    int size() { return len; }
    bool isEmpty() { return size() == 0; }

    T get(int index) { return arr[index]; }
    void set(int index, T elem) { arr[index] = elem; }

    void clear() {
        for (int i = 0; i < capacity; i++) {
            arr[i] = nullptr;
            len = 0;
        }
    }

    void add(T elem) {
        if (len + 1 >= capacity) {
            if (capacity == 0) capacity = 1;
            else capacity *= 2;
            T[] new_arr = (T[]) new Object[capacity];
            for (int i = 0; i < len; i++)
                new_arr[i] = arr[i];
            arr = new_arr; // arr has extra nulls padded
        }
        arr[len+=] = elem;
    }

    void removeAt(int rm_index) {
        if (rm_index >= len && rm_index < 0) throw new IndexOutOfBoundsException();
        T data = arr[rm_index];
        T[] new_arr = (T[]) new Object[len-1];
        for (int i = 0, j = 0; i < len; i++, j++)
            if (i == rm_index) j--;
            else new_arr[j] = arr[i];
        arr = new_arr;
        capacity = --len;
        return data;
    }

}
#+END_SRC


* Union Find (Disjoint Set)
- Keeps track of elements which are split into one or more disjoint sets.
- 2 primary operations:
  1. Find
  2. Union
